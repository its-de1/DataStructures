#Rotate a LinkedList

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Solution:
    
    #Function to rotate a linked list.
    def rotate(self, head, k):
        # code here
        if (k==0):
            return head
        curr=head
        count=0
        tail=head
        while(tail.next!=None):
            tail=tail.next
        tail.next=head
        s=head
        while(count<k-1):
            count+=1
            s=s.next
        head=s.next
        s.next=None
        return head

#{ 
#  Driver Code Starts
# driver

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def insert(self,val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next

def printList(n):
    while n:
        print(n.data, end=' ')
        n = n.next
    print()

if __name__=="__main__":
    for _ in range(int(input())):
        n = int(input())
        arr = [int(x) for x in input().split()]
        k = int(input())
        
        lis = LinkedList()
        for i in arr:
            lis.insert(i)
        
        head = Solution().rotate(lis.head,k)
        printList(head)
# } Driver Code Ends

------------------------------------------------------------------

#Check if Linked List is Palindrome

#User function Template for python3
'''
	Your task is to check if given linkedlist
	is a pallindrome or not.
	
	Function Arguments: head (reference to head of the linked list)
	Return Type: boolean , no need to print just return True or False.

	{
		# Node Class
		class Node:
		    def __init__(self, data):   # data -> value stored in node
		        self.data = data
		        self.next = None
	}

	Contributed By: Nagendra Jha
'''
#Function to check whether the list is palindrome.
class Solution:
    def isPalindrome(self, head):
        #code here
            fast,slow=head,head
            rev=None
            while fast and fast.next:
                fast=fast.next.next
                newslow=slow.next
                slow.next=rev
                rev=slow
                slow=newslow
            if fast:
                slow=slow.next
            while slow:
                if slow.data!=rev.data:
                    return False
                slow=slow.next
                rev=rev.next
            return True
#{ 
#  Driver Code Starts


import atexit
import io
import sys

class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None

# Linked List Class
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def append(self, new_value):
        new_node = Node(new_value)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
            return
        self.tail.next = new_node
        self.tail = new_node 

if __name__ == '__main__':
    t=int(input())
    for cases in range(t):
        n = int(input())
        a = LinkedList() # create a new linked list 'a'.
        nodes_a = list(map(int, input().strip().split()))
        for x in nodes_a:
            a.append(x)  # add to the end of the list

        if Solution().isPalindrome(a.head):
            print(1)
        else:
            print(0)
# } Driver Code Ends

-------------------------------------------------------------------

#Reverse a LinkedList
#function Template for python3

"""
# Node Class

class node:
    def __init__(self, val):
        self.data = val
        self.next = None

"""

class Solution:
    #Function to reverse a linked list.
    def reverseList(self, head):
        # Code here
        curr=head
        prev=None
        while(curr!=None):
            next=curr.next
            curr.next=prev
            prev=curr
            curr=next
        head=prev
        return head

#{ 
#  Driver Code Starts
# Node Class    
class Node:
    def __init__(self, val):
        self.data = val
        self.next = None

# Linked List Class
class Linked_List:
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next

def printList(head):
    tmp = head
    while tmp:
        print(tmp.data, end=' ')
        tmp=tmp.next
    print()

if __name__=='__main__':
    for i in range(int(input())):
        n = int(input())
        arr = [int(x) for x in input().split()]
        
        lis = Linked_List()
        for i in arr:
            lis.insert(i)
        
        newHead = Solution().reverseList(lis.head)
        printList(newHead)

# } Driver Code Ends

-------------------------------------------------------------------

#Middleelement in LinkedList

'''
class node:
    def __init__(data):
        self.data = data
        self.next = None
'''
class Solution:
    #  Should return data of middle node. If linked list is empty, then  -1
    def findMid(self, head):
        # Code here
        # return the value stored in the middle node
        temp=head
        length=0
        while (temp!=None):
              length=length+1
              temp=temp.next
        if(length%2!=0):
            length=length/2
            i=0
            temp=head
            while(i<length-1):
                 temp=temp.next
                 i+=1
            return temp.data
        else:
            length=length/2
            i=0
            temp=head
            while(i<length):
                 temp=temp.next
                 i+=1
            return temp.data
#{ 
#  Driver Code Starts
# Initial Template for Python3

# Node Class    
class node:
    def __init__(self):
        self.data = None
        self.next = None

# Linked List Class
class Linked_List:
    def __init__(self):
        self.head = None
        self.tail = None
        
    def insert(self, data):
        if self.head == None:
            self.head = node()
            self.tail = self.head
            self.head.data = data
        else:
            new_node = node()
            new_node.data = data
            new_node.next = None
            self.tail.next = new_node
            self.tail = self.tail.next

def printlist(head):
    temp = head
    while temp is not None:
        print(temp.data, end=" ")
        temp = temp.next
    print('')

# Driver Program
if __name__ == '__main__':
    t = int(input())
    for i in range(t):
        list1 = Linked_List()
        n = int(input())
        values = list(map(int, input().strip().split()))
        for i in values:
            list1.insert(i)
        ob = Solution()
        print(ob.findMid(list1.head))


# } Driver Code Ends

--------------------------------------------------------------------
#Nth Node from end of LinkedList

#User function Template for python3
'''


	{
		# Node Class
		class Node:
		    def __init__(self, data):   # data -> value stored in node
		        self.data = data
		        self.next = None
	}
'''
#Function to find the data of nth node from the end of a linked list
def getNthFromLast(head,n):
    #code here
    temp=head
    length=0
    while(temp!=None):
        length=length+1
        temp=temp.next
    temp=head
    if length<n:
        return -1
    else:
        length=length-n
        i=0
        while(i<=length-1):
           temp=temp.next
           i=i+1
    return temp.data
     
#{ 
#  Driver Code Starts

import atexit
import io
import sys

_INPUT_LINES = sys.stdin.read().splitlines()
input = iter(_INPUT_LINES).__next__
_OUTPUT_BUFFER = io.StringIO()
sys.stdout = _OUTPUT_BUFFER

@atexit.register

def write():
    sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())
    
# Node Class
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None

# Linked List Class
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    # creates a new node with given value and appends it at the end of the linked list
    def append(self, new_value):
        new_node = Node(new_value)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
            return
        self.tail.next = new_node
        self.tail = new_node

if __name__ == '__main__':
    t=int(input())
    for cases in range(t):
        n,nth_node = map(int, input().strip().split())
        a = LinkedList() # create a new linked list 'a'.
        nodes_a = list(map(int, input().strip().split()))
        for x in nodes_a:
            a.append(x)  # add to the end of the list
        print(getNthFromLast(a.head,nth_node))
# } Driver Code Ends

-------------------------------------------------------------------

Remove Loop in LinkedList

'''
# node class:

class Node:
    def __init__(self,val):
        self.next=None
        self.data=val

'''

class Solution:
    #Function to remove a loop in the linked list.
    def removeLoop(self, head):

        slow = fast = head
        while fast and fast.next:
            slow, fast = slow.next, fast.next.next
            if slow == fast: return 1
        else: return 0 # if not (fast and fast.next): return None
        while head != slow:
            head, slow = head.next, slow.next
        return head
#{ 
#  Driver Code Starts
# driver code:

class Node:
    def __init__(self,val):
        self.next=None
        self.data=val

class linkedList:
    def __init__(self):
        self.head=None
        self.tail=None
    
    def add(self,num):
        if self.head is None:
            self.head=Node(num)
            self.tail=self.head
        else:
            self.tail.next=Node(num)
            self.tail=self.tail.next
    
    def isLoop(self):
        if self.head is None:
            return False
        
        fast=self.head.next
        slow=self.head
        
        while slow != fast:
            if fast is None or fast.next is None:
                return False
            fast=fast.next.next
            slow=slow.next
        
        return True
    
    def loopHere(self,position):
        if position==0:
            return
        
        walk=self.head
        for _ in range(1,position):
            walk=walk.next
        self.tail.next=walk
    
    def length(self):
        walk=self.head
        ret=0
        while walk:
            ret+=1
            walk=walk.next
        return ret

if __name__=="__main__":
    t=int(input())
    for _ in range(t):
        n=int(input())
        arr=tuple(int(x) for x in input().split())
        pos=int(input())
        
        ll = linkedList()
        for i in arr:
            ll.add(i)
        ll.loopHere(pos)
        
        Solution().removeLoop(ll.head)
        
        if ll.isLoop() or ll.length()!=n:
            print(0)
            continue
        else:
            print(1)

# } Driver Code Ends

------------------------------------------------------------------

#Detect Loop in LinkedList

#User function Template for python3
'''
		# Node Class
		class Node:
		    def __init__(self, data):   # data -> value stored in node
		        self.data = data
		        self.next = None
	
'''
class Solution:
    #Function to check if the linked list has a loop.
    def detectLoop(self, head):
        #code here
        temp=head
        temp1=head
        while(temp1!=None and temp1.next!=None):
            temp=temp.next
            temp1=temp.next.next
            if (temp==temp1):
               return True
            if (temp1 == None or temp1.next == None):
               return False;
        
            
#{ 
#  Driver Code Starts
#Initial Template for Python 3

# Node Class
class Node:
    def __init__(self, data):   # data -> value stored in node
        self.data = data
        self.next = None

# Linked List Class
class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    # creates a new node with given value and appends it at the end of the linked list
    def insert(self, val):
        if self.head is None:
            self.head = Node(val)
            self.tail = self.head
        else:
            self.tail.next = Node(val)
            self.tail = self.tail.next
    
    #connects last node to node at position pos from begining.
    def loopHere(self,pos):
        if pos==0:
            return
        
        walk = self.head
        for i in range(1,pos):
            walk = walk.next
        
        self.tail.next = walk

if __name__ == '__main__':
    for _ in range(int(input())):
        n = int(input())
        
        LL = LinkedList()
        for i in input().split():
            LL.insert(int(i))
        
        LL.loopHere(int(input()))
        
        print(Solution().detectLoop(LL.head))
# } Driver Code Ends



#print LinkedList
  def display(self,node):
        #code here
        while(node!=None):
            print (node.data,end=" ")
            node=node.next

-------------------------------------------------------------------

# delete a xth node in LinkedList
  def delNode(head, k):
    # Code here
    if k<0:
        return None
    if k==1:
        head=head.next
        return head
    i=1
    prev=head
    temp=head
    while(temp is not None):
        if i==k:
            prev.next=temp.next
            return head
        prev=temp
        temp=temp.next
        i+=1
-------------------------------------------------------------------
#Merge Two Sorted List

  def sortedMerge(head1, head2):
    # code here
    if head1 is None and head2 is None:
        return None;
    
    temp1=head1
    temp2=head2
    temp=[]
    i=0
    while(temp1!=None):
        temp.append(temp1.data)
        temp1=temp1.next
    while(temp2!=None):
        temp.append(temp2.data)
        temp2=temp2.next

    head=Node(-1)
    temp4=head
    temp.sort()
 
    while(i <len(temp)):
        temp4.next=Node(temp.pop(i))
        temp4=temp4.next
        
    return head.next
-------------------------------------------------------------------

#Count Node of LinkedList
def getCount(self, head_node):
        #code here
        temp=head_node
        length=0
        while(temp is not None):
            temp=temp.next
            length+=1
return length
-------------------------------------------------------------------
#remove duplicate from an unsortefd linkedlist
def removeDuplicates(self, head):
	dic={}
        if head ==None and head.next==None:
            return None
        else:
            temp=head
            dic[temp.data]=1
            while temp.next is not None:
                if temp.next.data in dic:
                    temp.next=temp.next.next
                else:
                    dic[temp.next.data]=1
                    temp=temp.next
   return head
-------------------------------------------------------------------

#Create a link list of size N according to the given input literals.
Each integer input is accompanied by an indicator which can either
be 0 or 1. If it is 0, insert the integer in the beginning of the link list.
If it is 1, insert the integer at the end of the link list.
class Solution:
    #Function to insert a node at the beginning of the linked list.
    def insertAtBegining(self,head,x):
        # code here 
        temp=Node(x)
        temp.next=head
        return temp
    #Function to insert a node at the end of the linked list.
    def insertAtEnd(self,head,x):
        # code here 
        temp= head
        if (temp!=None){
            while(temp.next!=None)
                temp=temp.next;
            temp.next=Node(x);}
        else
            head=Node(x);
        return head;
 
-------------------------------------------------------------------
#Reverse a linked list in group of given size

    def reverse(self,head, k):
        # Code here
        temp=head
        last=None
        flag=0
        while(temp!=None):
            prev=None
            start=temp
            next=start.next
            first=start
            i=0
            while(i<k and temp!=None):
                if(temp!=None):
                    temp=temp.next
                start.next=prev
                prev=start
                start=next
                if(start!=None):
                    next=start.next
                i+=1
            if (flag==0):
                head=prev
                last=first
                flag=1
            else:
                last.next=prev
                last=first
                
        return head

-------------------------------------------------------------------
#You are given a pointer/ reference to the node which is to be deleted from the linked list of N nodes. 
The task is to delete the node. Pointer/ reference to head node is not given. 
Note: No head reference is given to you. It is guaranteed that the node to be deleted is 
not a tail node in the linked list.

class Solution:
    #Function to delete a node without any reference to head pointer.
    def deleteNode(self,curr_node):
        #code here
            curr_node.data=curr_node.next.data
            curr_node.next=curr_node.next.next

-------------------------------------------------------------------
#Remove duplicate element from sorted Linked List
def removeDuplicates(head):
    #code here 
    temp1=head
    temp2=head.next
    while(temp2!=None):
        if(temp1.data==temp2.data):
            temp2=temp2.next
            temp1.next=temp2
        else:
            temp1=temp1.next
            temp2=temp2.next
    return head


-------------------------------------------------------------------
#Intersection of two sorted Linked lists
def findIntersection(head1,head2):
    #return head
    store=Node(-1)
    temp=store
    temp1=head1
    temp2=head2
    while(temp1 is not None and temp2 is not None):
        if(temp1.data ==temp2.data):
            newNode=Node(temp1.data)
            temp.next=newNode
            temp=temp.next
            temp1=temp1.next
            temp2=temp2.next
        elif (temp1.data <temp2.data):
            temp1=temp1.next
        else:
            temp2=temp2.next
            
    return store.next
-------------------------------------------------------------------
Check if Circular Linked list
def isCircular(head):
    # Code here
        temp=head

    if (head==None):
        return True
    if (head.next==head):
        return True
    while(temp.next!=head):
        temp=temp.next
        if temp==None:
            return False
    return True
-------------------------------------------------------------------

Flattening a Linked List
def flatten(root):
    #Your code here
    if (root==None or root.next==None):
        return root
    root.next=flatten(root.next)
    
    root=mergeTwoList(root,root.next);
    return root
    
def mergeTwoList(a,b):
   temp = Node(0)
   res=temp
   
   while(a!=None and b!=None):
       if(a.data<b.data):
           temp.bottom = a
           a = a.bottom
           temp=temp.bottom
       else:
           temp.bottom = b
           temp = temp.bottom
           b = b.bottom
   
   temp.bottom = a if(a!=None) else b
   return res.bottom

-------------------------------------------------------------------
#Given a linked list of size N. The task is to complete the function countNodesinLoop() that checks whether a given Linked List contains a loop or not and if the loop is present then return the count of nodes in a loop or else return 0. C is the position of the node to which the last node is connected. If it is 0 then no loop.

def countNodesinLoop(head):
    #Your code here
    count=0
    temp,temp1=head,head
    while temp1 and temp1.next:
        temp=temp.next
        temp1=temp1.next.next
        
        if temp1==temp:
            count+=1
            temp=temp.next
            
            while temp!=temp1:
                count+=1
                temp=temp.next
            return count
    return 0
 

-------------------------------------------------------------------

#Given a linked list of 0s, 1s and 2s, sort it. 
def segregate(self, head):
        #code here
        temp=head
        count0=0
        count1=0
        count2=0
        while(temp!=None):
            if temp.data==0:
                count0+=1
            elif temp.data==1:
                count1+=1
            else:
                count2+=1
            temp=temp.next
        temp=head
        while(count0):
            temp.data=0
            temp=temp.next
            count0-=1
        while(count1):
            temp.data=1
            temp=temp.next
            count1-=1
        while(count2):
            temp.data=2
            temp=temp.next
            count2-=1
        return head
-------------------------------------------------------------------
#Count Pairs whose sum is equal to X
 def countPair(self,h1,h2,n1,n2,x):
        '''
        h1:  head of linkedList 1
        h2:  head of linkedList 2
        n1:  len of  linkedList 1
        n2:   len of linkedList 1
        X:   given sum
        '''
        count=0
        temp=set()
        if n1<=n2:
            while h1:
                temp.add(h1.data)
                h1=h1.next
            h=h2
        else:
            while h2:
                temp.add(h2.data)
                h2=h2.next
            h=h1
        while h:
            if x-h.data in temp:
                count+=1
                h=h.next
        return count
-------------------------------------------------------------------
#Delete Middle of Linked List
def deleteMid(head):
    '''
    head:  head of given linkedList
    return: head of resultant llist
    '''
    length=1
    temp=head
    while(temp.next!=None):
        length+=1
        temp=temp.next
        
    if length%2==0:
        remo=length/2+1
    else:
        remo=math.ceil(length/2)
    temp=head
    prev=None
    i=1
    while i<remo-1:
        temp=temp.next
        i+=1
    temp.next=temp.next.next
    return head
    -------------------------------------------------------------------
#Occurence of an integer in a Linked List
class Solution:
    def count(self, head, search_for):
        # Code here
        temp=head
        temp1=0
        while temp!=None:
            if temp.data==search_for:
                temp1+=1
            temp=temp.next
        return temp1  
-------------------------------------------------------------------
Sorted insert for circular linked list
   def sortedInsert(self, head, data):
        #code here
        x=Node(data)
        if head==None:
            x.next=x
            return x
        temp=head.next
        prev=headInsert in a Sorted List
        while prev.next!=head:
            prev=temp
            temp=temp.next
            if temp.data>data:
               
                prev.next=x
                x.next=temp
        x=Node(data)
        prev.next=x
        x.next=temp
        return head  
-------------------------------------------------------------------
#Insert in a Sorted List
def sortedInsert(self, head1,key):
        # code here
        # return head of edited linked list
        node=Node(key)
        if head1.data>key:
            node.next=head1
            return node
        curr=head1
        prev=None
        while(curr):
            if curr.data>key:
                prev.next=node
                node.next=curr
                return head1
            prev=curr
            curr=curr.next
        prev.next=node
        return head1
-------------------------------------------------------------------
#Reverse a Doubly Linked List
def reverseDLL(head):
    #return head after reversing
   ptr = None
   ptr1 = head
   
   while ptr1 != None:
       val = ptr1.next
       ptr1.prev = val
       ptr1.next = ptr
       ptr = ptr1
       ptr1 = val
   head = ptr
   return head
------------------------------------------------------------------- 
#Remove every k'th node
def deleteK(head, k):
    #code here
    if k == 1:
       return None
    if k==0:
       return head
    node = head
    index = 1
    while(node):
       if (index+1) % k == 0 and node.next is not None:
           node.next = node.next.next
           index += 2
           node = node.next
       else:
           node = node.next
           index+=1
    return head
 -------------------------------------------------------------------
 #Given a singly linked list of size N. The task is to swap elements in the linked list pairwise.
For example, if the input list is 1 2 3 4, the resulting list after swaps will be 2 1 4 3.
def pairWiseSwap(self, head):
        # code here
        if head.next is None:
            return head
        cur=head
        temp=head.next
        prev=Node(-1)
        while cur and cur.next:
            prev.next=cur.next
            cur.next=cur.next.next
            prev.next.next=cur
            cur=cur.next
            prev=prev.next.next
        return temp

-------------------------------------------------------------------
#Given a singly linked list L0 -> L1 -> … -> Ln-1 -> Ln. Rearrange the nodes in the list so that the new formed list is: L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2.
from collections import deque
def inPlace(root):
    #code here
    dq=deque()
    current=root
    current1=root
    while current!=None:
       dq.append(current.data)
       current=current.next
    position=0
    while current1!=None:
       if position%2!=0:
           temp=dq.pop()
           current1.data=temp
           position+=1
       else:
           current1.data=dq.popleft()
           position+=1
       current1=current1.next
    return root
-------------------------------------------------------------------
#Arrange Consonants and Vowels
def arrangeCV(self, head):
        # Code here
        dq=deque()
        dq1=deque()
        current=head
        while current!=None:
            if current.data=='a' or current.data=='e' or current.data==current.data=='i' or current.data=='o' or current.data=='u':
               dq.append(current.data)
            else:
               dq1.append(current.data)
            current=current.next
        current1=head
        while current1!=None and len(dq)!=0:
            current1.data=dq.popleft()
            current1=current1.next
        while current1!=None and len(dq1)!=0:
            current1.data=dq1.popleft()
            current1=current1.next
        return head

-------------------------------------------------------------------
#Split Singly Linked List Alternatingly
def alternatingSplitList(head):
    
    global a,b
    #Your code here
    if head==None:
        return
    c=0
    first=Node(-1)
    second=Node(-1)
    firstp=first
    secondp=second
    temp=head
    while temp!=None:
        if c%2==0:
            firstp.next=temp
            firstp=firstp.next
        else:
            secondp.next=temp
            secondp=secondp.next
        temp=temp.next
        c+=1
    firstp.next=None
    secondp.next=None
    a=first.next
    b=second.next
  
-------------------------------------------------------------------
  #Merge Lists Alternatingly 
  hea1=head1
    hea2=head2
    while hea1!=None and hea2!=None:
        p=hea1.next
        l=node(hea2.data)
        l.next=p
        hea1.next=l
        hea1=p
        hea2=hea2.next

    return [head1,hea2]

-------------------------------------------------------------------
#Linked List that is Sorted Alternatingly 
def sort(h1):
    #return head
    arr=[]
    temp=h1
    while temp!=None:
        arr.append(temp.data)
        temp=temp.next
    arr.sort()
    new=Node(-1)
    new1=new
    for i in range(0,len(arr)):
        new.next=Node(arr[i])
        new=new.next
    return new1.next
  -------------------------------------------------------------------
  #Move all zeros to the front of the linked lis
  def moveZeroes(self):
        count0=0
        if head==None:
            return
        temp,t=head,head
        while(temp!=None):
            if temp.data==0:
                 count0+=1
            temp=temp.next
        while t.data==0:
            t=t.next
            head=t
        while t.next is not None:
            if t.next.data==0:
                t.next=t.next.next
            else:
                t=t.next
        while count:
            add(head,0)
            count-=1
-------------------------------------------------------------------
#Linked List in Zig-Zag fashion
def zigzag(self, head_node):
        # Complete this function
        flag=True
        curr=head_node
        while curr.next:
            if flag:
                if curr.data > curr.next.data:
                    temp=curr.data
                    curr.data=curr.next.data
                    curr.next.data=temp
            else:
                if curr.data <curr.next.data:
                    temp=curr.data
                    curr.data=curr.next.data
                    curr.next.data=temp
            flag=not flag
            curr=curr.next
        return head_node
-------------------------------------------------------------------
#Insert in Sorted way in a Sorted DLL
def sortedInsert(head, x):
    #code here
    temp=Node(x)
    c1=head
    if head==None:
       return temp
       
    if head.data>temp.data:
       temp.next=head
       head.prev=temp
       return temp
       
    if head.next==None:
       head.next=temp
       temp.prev=head
       return head
       
    while c1.next.data<temp.data:
       c1=c1.next
       if c1.next==None:
           break
   
    if c1.next==None:
       c1.next=temp
       temp.prev=c1
       return head
    else:
       temp.next=c1.next
       c1.next.prev=temp
       temp.prev=c1
       c1.next=temp
       return head
    -------------------------------------------------------------------   
#Deletion and Reverse in Linked List
def deleteNode(head, key):
    #your code goes here
    curr=head
    while(curr.next.data!=key):
        curr=curr.next
    curr.next=curr.next.next
    return head.data==d?curr.next:head;
    
-------------------------------------------------------------------
#Function to reverse the list
def reverse(head):
    #your code goes here
    curr=head
    prev=None
    while curr is not head:
        temp=curr.next
        curr.next=prev
        prev=curr
        curr=temp
    head.next=prev
    return prev
  -------------------------------------------------------------------  
#Subtraction in Linked ListSubtraction in Linked List

def subLinkedList(l1, l2): 
    # Code here
    # return head of difference list
    num1 = num(l1)
    num2 = num(l2)
   
    if(num1 > num2):
        subtract(num1,num2)
    else:
        subtract(num2,num1)
   
def num(head):
    s = ""
    curr = head
    while curr:
        s += str(curr.data)
        curr = curr.next
    return int(s)
   
def subtract(n1,n2):
    sub = str(n1 - n2)
    LL = LinkedList()
    for i in range(len(sub)):
        val = int(sub[i])
        LL.insert(val)
        print (LL.get(i))
    return LL.head
 
-------------------------------------------------------------------
#linked list of strings forms a palindrome 
def compute(head): 
    #return True/False
 
    #return True/False
    n = head
    s = []
    while n:
        s.append(n.data)
        n=n.next
    if s == s[::-1]:
        return True
    else:
        return False
-------------------------------------------------------------------
-------------------------------------------------------------------
 
    
    
